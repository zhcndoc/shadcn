---
title: Next.js
description: 使用 useActionState 和服务器操作在 React 中构建表单。
---

import { InfoIcon } from "lucide-react"

在本指南中，我们将介绍如何使用 Next.js 中的 `useActionState` 和服务器操作来构建表单。内容涵盖表单构建、验证、挂起状态、无障碍访问等。

## 演示

我们将构建如下的表单，包含一个简单的文本输入框和一个文本区域。提交时，我们将使用服务器操作来验证表单数据并更新表单状态。

<ComponentPreview
  name="form-next-demo"
  className="[&_.preview]:h-[700px] [&_pre]:!h-[700px]"
/>

<Callout icon={<InfoIcon />}>
  **注意：** 本页示例故意禁用了浏览器验证，以展示服务器操作中架构验证和表单错误的工作方式。
</Callout>

## 方法

该表单利用了 Next.js 和 React 内置的表单处理能力。我们将使用 `<Field />` 组件构建表单，它为你提供了**完全的标记和样式自由**。

- 使用 Next.js 的 `<Form />` 组件实现导航和渐进式增强。
- 使用 `<Field />` 组件构建无障碍表单。
- 使用 `useActionState` 管理表单状态和错误。
- 通过 pending 属性处理加载状态。
- 使用服务器操作处理表单提交。
- 使用 Zod 进行服务器端验证。

## 结构

下面是一个使用 `<Field />` 组件的基本表单示例。

```tsx showLineNumbers
<Form action={formAction}>
  <FieldGroup>
    <Field data-invalid={!!formState.errors?.title?.length}>
      <FieldLabel htmlFor="title">错误标题</FieldLabel>
      <Input
        id="title"
        name="title"
        defaultValue={formState.values.title}
        disabled={pending}
        aria-invalid={!!formState.errors?.title?.length}
        placeholder="登录按钮在手机上无法使用"
        autoComplete="off"
      />
      <FieldDescription>
        请简洁描述你的错误报告标题。
      </FieldDescription>
      {formState.errors?.title && (
        <FieldError>{formState.errors.title[0]}</FieldError>
      )}
    </Field>
  </FieldGroup>
  <Button type="submit">提交</Button>
</Form>
```

## 用法

### 创建表单架构

首先我们使用 Zod 在 `schema.ts` 文件中定义表单的数据结构。

<Callout icon={<InfoIcon />}>
  **注意：** 本示例使用的是 `zod v3` 进行架构验证，但你可以替换为其他任何符合标准架构规范的验证库。
</Callout>

```tsx showLineNumbers title="schema.ts"
import { z } from "zod"

export const formSchema = z.object({
  title: z
    .string()
    .min(5, "错误标题至少需要5个字符。")
    .max(32, "错误标题最多32个字符。"),
  description: z
    .string()
    .min(20, "描述至少需要20个字符。")
    .max(100, "描述最多100个字符。"),
})
```

### 定义表单状态类型

接下来，我们定义一个表单状态类型，包含值、错误和成功状态。这将在客户端和服务器端用于表单状态的类型定义。

```tsx showLineNumbers title="schema.ts"
import { z } from "zod"

export type FormState = {
  values?: z.infer<typeof formSchema>
  errors: null | Partial<Record<keyof z.infer<typeof formSchema>, string[]>>
  success: boolean
}
```

**重要提示：** 我们将架构和 `FormState` 类型定义在单独文件，方便在客户端和服务器组件中导入使用。

### 创建服务器操作

服务器操作是运行在服务器上并可以被客户端调用的函数。我们将它用于验证表单数据并更新表单状态。

<ComponentSource
  src="/registry/new-york-v4/examples/form-next-demo-action.ts"
  title="actions.ts"
/>

**注意：** 对于错误情况，我们返回 `values`，目的是保持用户提交的值在表单状态中。对于成功情况则返回空的值以重置表单。

### 构建表单

现在我们可以使用 `<Field />` 组件构建表单。使用 `useActionState` 钩子管理表单状态、服务器操作及挂起状态。

<ComponentSource
  src="/registry/new-york-v4/examples/form-next-demo.tsx"
  title="form.tsx"
/>

### 完成

就是这样。你现在拥有了一个全无障碍且具备客户端和服务器端验证的完整表单。

提交表单时，服务器上的 `formAction` 函数将被调用。服务器操作会验证表单数据并更新表单状态。

如果数据无效，服务器操作将返回错误给客户端；如果有效，服务器操作则返回成功状态并更新表单。

## 挂起状态

使用 `useActionState` 返回的 `pending` 属性来显示加载指示器并禁用表单输入。

```tsx showLineNumbers {11,26-34}
"use client"

import * as React from "react"
import Form from "next/form"

import { Spinner } from "@/components/ui/spinner"

import { bugReportFormAction } from "./actions"

export function BugReportForm() {
  const [formState, formAction, pending] = React.useActionState(
    bugReportFormAction,
    {
      errors: null,
      success: false,
    }
  )

  return (
    <Form action={formAction}>
      <FieldGroup>
        <Field data-disabled={pending}>
          <FieldLabel htmlFor="name">姓名</FieldLabel>
          <Input id="name" name="name" disabled={pending} />
        </Field>
        <Field>
          <Button type="submit" disabled={pending}>
            {pending && <Spinner />} 提交
          </Button>
        </Field>
      </FieldGroup>
    </Form>
  )
}
```

## 禁用状态

### 提交按钮

要禁用提交按钮，请将 `pending` 传给按钮的 `disabled` 属性。

```tsx showLineNumbers
<Button type="submit" disabled={pending}>
  {pending && <Spinner />} 提交
</Button>
```

### 字段

要为 `<Field />` 组件应用禁用状态及样式，请使用 `<Field />` 组件的 `data-disabled` 属性。

```tsx showLineNumbers
<Field data-disabled={pending}>
  <FieldLabel htmlFor="name">姓名</FieldLabel>
  <Input id="name" name="name" disabled={pending} />
</Field>
```

## 验证

### 服务器端验证

在服务器操作中使用架构的 `safeParse()` 方法验证表单数据。

```tsx showLineNumbers title="actions.ts" {12-20}
"use server"

export async function bugReportFormAction(
  _prevState: FormState,
  formData: FormData
) {
  const values = {
    title: formData.get("title") as string,
    description: formData.get("description") as string,
  }

  const result = formSchema.safeParse(values)

  if (!result.success) {
    return {
      values,
      success: false,
      errors: result.error.flatten().fieldErrors,
    }
  }

  return {
    errors: null,
    success: true,
  }
}
```

### 业务逻辑验证

你可以在服务器操作中添加额外的自定义验证逻辑。

在验证出错时，一定要返回 values，以确保表单状态保留用户输入的数据。

```tsx showLineNumbers title="actions.ts" {22-35}
"use server"

export async function bugReportFormAction(
  _prevState: FormState,
  formData: FormData
) {
  const values = {
    title: formData.get("title") as string,
    description: formData.get("description") as string,
  }

  const result = formSchema.safeParse(values)

  if (!result.success) {
    return {
      values,
      success: false,
      errors: result.error.flatten().fieldErrors,
    }
  }

  // 检查邮箱是否已存在数据库中。
  const existingUser = await db.user.findUnique({
    where: { email: result.data.email },
  })

  if (existingUser) {
    return {
      values,
      success: false,
      errors: {
        email: ["该邮箱已被注册"],
      },
    }
  }

  return {
    errors: null,
    success: true,
  }
}
```

## 错误显示

使用 `<FieldError />` 在对应字段旁显示错误。确保对 `<Field />` 组件添加 `data-invalid` 属性，并对输入框添加 `aria-invalid` 属性。

```tsx showLineNumbers
<Field data-invalid={!!formState.errors?.email?.length}>
  <FieldLabel htmlFor="email">邮箱</FieldLabel>
  <Input
    id="email"
    name="email"
    type="email"
    aria-invalid={!!formState.errors?.email?.length}
  />
  {formState.errors?.email && (
    <FieldError>{formState.errors.email[0]}</FieldError>
  )}
</Field>
```

## 重置表单

使用服务器操作提交表单时，React 会自动重置表单状态为初始值。

### 成功时重置

成功时可省略服务器操作返回的 `values`，React 将自动将表单重置为初始状态。这是 React 的标准行为。

```tsx showLineNumbers title="actions.ts" {22-26}
export async function demoFormAction(
  _prevState: FormState,
  formData: FormData
) {
  const values = {
    title: formData.get("title") as string,
    description: formData.get("description") as string,
  }

  // 验证。
  if (!result.success) {
    return {
      values,
      success: false,
      errors: result.error.flatten().fieldErrors,
    }
  }

  // 业务逻辑。
  callYourDatabaseOrAPI(values)

  // 成功时省略 values, 以重置表单状态。
  return {
    errors: null,
    success: true,
  }
}
```

### 验证错误时保留输入

为防止验证失败时重置表单，可以在服务器操作中返回 values，确保保留用户输入。

```tsx showLineNumbers title="actions.ts" {12-17}
export async function demoFormAction(
  _prevState: FormState,
  formData: FormData
) {
  const values = {
    title: formData.get("title") as string,
    description: formData.get("description") as string,
  }

  // 验证。
  if (!result.success) {
    return {
      // 验证错误时返回 values。
      values,
      success: false,
      errors: result.error.flatten().fieldErrors,
    }
  }
}
```

## 复杂表单

以下示例展示了更复杂的包含多个字段和验证的表单。

<ComponentPreview
  name="form-next-complex"
  className="[&_.preview]:h-[1100px] [&_pre]:!h-[1100px]"
  hideCode
/>

### 架构

<ComponentSource
  src="/registry/new-york-v4/examples/form-next-complex-schema.ts"
  title="schema.ts"
/>

### 表单

<ComponentSource
  src="/registry/new-york-v4/examples/form-next-complex.tsx"
  title="form.tsx"
/>

### 服务器操作

<ComponentSource
  src="/registry/new-york-v4/examples/form-next-complex-action.ts"
  title="actions.ts"
/>